{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-db10d24332c2cbca02adb6fe13b56e638d8ee80e",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Escrow.sol": "project/contracts/Escrow.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "project/contracts/Escrow.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IEscrow} from \"./interfaces/IEscrow.sol\";\n\n// Escrow contracts for bookings\n\ncontract Escrow is IEscrow {\n    // Token used for payments\n    IERC20 public token;\n\n    // Store challenges\n    uint256 public challengesCount;\n    mapping(uint256 => Challenge) public challenges;\n\n    // Store challenge for which the user is the admin for easy retrieval\n    mapping(address => uint256[]) public adminChallenges;\n\n    // Withdrawal balances\n    mapping(address => uint256) public balances;\n\n    // Store submissions\n    mapping(uint256 => uint256) public submissionsCount;\n    mapping(uint256 => mapping(uint256 => Submission)) public submissions;\n    mapping(uint256 => mapping(address => bool)) public submitted;\n\n    constructor(address _token) {\n        token = IERC20(_token);\n    }\n\n    modifier onlyAdmin(uint256 challengeId) {\n        if (challenges[challengeId].admin != msg.sender) {\n            revert OnlyAdmin();\n        }\n        _;\n    }\n\n    /// @inheritdoc IEscrow\n    function createChallenge(\n        string calldata metadataURI,\n        uint256 poolSize,\n        uint256 deadline\n    ) public {\n        challenges[challengesCount] = Challenge({\n            metadataUri: metadataURI,\n            poolSize: poolSize,\n            endsAt: deadline,\n            createdAt: block.timestamp,\n            status: ChallengeStatus.Active,\n            admin: msg.sender\n        });\n        \n        adminChallenges[msg.sender].push(challengesCount);\n        \n        emit ChallengeCreated(challengesCount, metadataURI, poolSize, deadline);\n        challengesCount++;\n    }\n\n    /// @inheritdoc IEscrow\n    function getChallenge(uint256 challengeId) public view returns (Challenge memory) {\n        return challenges[challengeId];\n    }\n\n    /// @inheritdoc IEscrow\n    function getChallenges(uint256 startIndex, uint256 count) public view returns (Challenge[] memory) {\n        uint256 endIndex = startIndex + count;\n        if (endIndex > challengesCount) {\n            endIndex = challengesCount;\n        }\n        Challenge[] memory challengeList = new Challenge[](endIndex - startIndex);\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            challengeList[i - startIndex] = challenges[i];\n        }\n        return challengeList;\n    }\n\n    /// @inheritdoc IEscrow\n    function getChallengesCount() public view returns (uint256) {\n        return challengesCount;\n    }\n\n    /// @inheritdoc IEscrow\n    function getAdminChallenges(address admin) public view returns (uint256[] memory) {\n        return adminChallenges[admin];\n    }\n\n    /// @inheritdoc IEscrow\n    function createSubmission(uint256 challengeId, string calldata contact,  string calldata submissionURI) public {\n        if (submitted[challengeId][msg.sender]) {\n            revert AlreadySubmitted();\n        }\n\n        uint256 submissionId = submissionsCount[challengeId];\n\n        submissions[challengeId][submissionId] = Submission({\n            creator: msg.sender,\n            creatorContact: contact,\n            metadataUri: submissionURI,\n            status: SubmissionStatus.Pending,\n            createdAt: block.timestamp\n        });\n        submissionsCount[challengeId]++;\n        submitted[challengeId][msg.sender] = true;\n        emit SubmissionCreated(submissionId, challengeId, msg.sender);\n    }\n\n    /// @inheritdoc IEscrow\n    function getSubmission(\n        uint256 challengeId,\n        uint256 submissionId\n    ) public view returns (Submission memory) {\n        return submissions[challengeId][submissionId];\n    }\n\n    /// @inheritdoc IEscrow\n    function getSubmissions(uint256 challengeId, uint256 startIndex, uint256 count) public view returns (Submission[] memory) {\n        uint256 endIndex = startIndex + count;\n        if (endIndex > submissionsCount[challengeId]) {\n            endIndex = submissionsCount[challengeId];\n        }\n        Submission[] memory submissionList = new Submission[](endIndex - startIndex);\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            submissionList[i] = submissions[challengeId][i];\n        }\n        return submissionList;\n    }\n\n    /// @inheritdoc IEscrow\n    function getSubmissionsCount(uint256 challengeId) public view returns (uint256) {\n        return submissionsCount[challengeId];\n    }\n\n    /// @inheritdoc IEscrow\n    function resolveChallenge(\n        uint256 challengeId,\n        uint256[] calldata awardedSubmissions,\n        uint256[] calldata ineligibleSubmissions\n    ) public onlyAdmin(challengeId) {\n        if (challenges[challengeId].endsAt > block.timestamp) {\n            revert ChallengeNotClosed();\n        }\n\n        // Update challenge status to completed\n        challenges[challengeId].status = ChallengeStatus.Completed;\n\n        // Mark awarded submissions as Awarded and collect winner addresses\n        address[] memory winners = new address[](awardedSubmissions.length);\n        for (uint256 j = 0; j < awardedSubmissions.length; j++) {\n            submissions[challengeId][awardedSubmissions[j]].status = SubmissionStatus.Awarded;\n            winners[j] = submissions[challengeId][awardedSubmissions[j]].creator;\n        }\n\n        // Mark ineligible submissions as Ineligible\n        for (uint256 j = 0; j < ineligibleSubmissions.length; j++) {\n            submissions[challengeId][ineligibleSubmissions[j]].status = SubmissionStatus.Ineligible;\n        }\n\n        // Filter out awarded and ineligible submissions to get the rest (losers)\n        address[] memory accepted = new address[](submissionsCount[challengeId] - awardedSubmissions.length - ineligibleSubmissions.length);\n        uint256 acceptedIndex = 0;\n        for (uint256 i = 0; i < submissionsCount[challengeId]; i++) {\n            bool isAwarded = false;\n            bool isIneligible = false;\n            \n            // Check if submission is awarded\n            for (uint256 j = 0; j < awardedSubmissions.length; j++) {\n                if (i == awardedSubmissions[j]) {\n                    isAwarded = true;\n                    break;\n                }\n            }\n            \n            // Check if submission is ineligible\n            for (uint256 j = 0; j < ineligibleSubmissions.length; j++) {\n                if (i == ineligibleSubmissions[j]) {\n                    isIneligible = true;\n                    break;\n                }\n            }\n            \n            // If not awarded and not ineligible, add to losers and mark as Accepted\n            if (!isAwarded && !isIneligible) {\n                accepted[acceptedIndex] = submissions[challengeId][i].creator;\n                acceptedIndex++;\n                submissions[challengeId][i].status = SubmissionStatus.Accepted;\n            }\n        }\n\n        // Reward distribution: Winners get 70% if there are losers, otherwise 100%\n        uint256 totalPool = challenges[challengeId].poolSize;\n        if (accepted.length > 0) {\n            // Winners get 70%, losers get 30%\n            uint256 winnerPoolSize = (totalPool * 70) / 100;\n            uint256 loserPoolSize = totalPool - winnerPoolSize;\n            \n            // Distribute to winners\n            uint256 winnerReward = winnerPoolSize / winners.length;\n            for (uint256 i = 0; i < winners.length; i++) {\n                balances[winners[i]] += winnerReward;\n            }\n            \n            // Distribute to losers\n            uint256 loserReward = loserPoolSize / accepted.length;\n            for (uint256 i = 0; i < accepted.length; i++) {\n                balances[accepted[i]] += loserReward;\n            }\n        } else {\n            // Winners take 100% of the pool\n            uint256 winnerReward = totalPool / winners.length;\n            for (uint256 i = 0; i < winners.length; i++) {\n                balances[winners[i]] += winnerReward;\n            }\n        }\n        \n        emit ChallengeResolved(challengeId, winners);\n    }\n\n    /// @inheritdoc IEscrow\n    function withdraw(uint256 amount, address to) public {\n        if (balances[msg.sender] < amount) {\n            revert InsufficientBalance();\n        }\n\n        // transfer funds back to the requestor\n        token.transfer(to, amount);\n        balances[msg.sender] -= amount;\n        emit FundsWithdrawn(msg.sender, to, amount);\n    }\n\n    /// @inheritdoc IEscrow\n    function getBalance(address account) public view returns (uint256) {\n        return balances[account];\n    }\n}\n"
      },
      "project/contracts/interfaces/IEscrow.errors.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\n/**\n * @title IEscrowErrors\n * @notice Interface defining all custom errors used by the Escrow contract\n * @dev Custom errors provide more gas-efficient error handling compared to require strings\n */\ninterface IEscrowErrors {\n    /**\n     * @notice Thrown when attempting to perform an action on a challenge that has already been closed\n     * @dev A challenge is considered closed once its deadline has passed\n     */\n    error ChallengeAlreadyClosed();\n\n    /**\n     * @notice Thrown when a user attempts to submit to a challenge they have already submitted to\n     * @dev Each address can only submit once per challenge to prevent spam\n     */\n    error AlreadySubmitted();\n\n    /**\n     * @notice Thrown when attempting to resolve a challenge before its deadline\n     * @dev Challenges can only be resolved after their deadline has passed to ensure fair submission periods\n     */\n    error ChallengeNotClosed();\n\n    /**\n     * @notice Thrown when attempting an action that requires a challenge to be in pending state\n     * @dev Currently defined but not actively used in the current implementation\n     */\n    error ChallengeNotPending();\n\n    /**\n     * @notice Thrown when attempting an action that requires a challenge to be in validating state\n     * @dev Currently defined but not actively used in the current implementation\n     */\n    error ChallengeNotValidating();\n\n    /**\n     * @notice Thrown when attempting an action that requires a challenge to be refunded\n     * @dev Currently defined but not actively used in the current implementation\n     */\n    error ChallengeNotRefunded();\n\n    /**\n     * @notice Thrown when a user attempts to withdraw more funds than their available balance\n     * @dev Prevents users from withdrawing funds they haven't earned or already withdrawn\n     */\n    error InsufficientBalance();\n\n    /**\n     * @notice Thrown when a user attempts to perform an action that requires them to be the admin of the challenge\n     * @dev Prevents users from performing actions that require them to be the admin of the challenge\n     */\n    error OnlyAdmin();\n}"
      },
      "project/contracts/interfaces/IEscrow.events.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\nimport {IEscrowStructs} from \"./IEscrow.structs.sol\";\n\n/**\n * @title IEscrowEvents\n * @notice Interface defining all events emitted by the Escrow contract\n * @dev These events provide transparency and allow off-chain applications to track escrow activity\n */\ninterface IEscrowEvents {\n    /**\n     * @notice Emitted when a new challenge is created\n     * @param challengeId The unique identifier of the created challenge\n     * @param metadataURI URI pointing to challenge metadata (description, requirements, etc.)\n     * @param poolSize The total reward pool size for this challenge\n     * @param deadline The timestamp after which submissions are no longer accepted\n     */\n    event ChallengeCreated(uint256 challengeId, string metadataURI, uint256 poolSize, uint256 deadline);\n\n    /**\n     * @notice Emitted when a challenge is resolved and rewards are distributed\n     * @param challengeId The unique identifier of the resolved challenge\n     * @param winners Array of addresses that won the challenge\n     */\n    event ChallengeResolved(uint256 challengeId, address[] winners);\n\n    /**\n     * @notice Emitted when funds are withdrawn from a specific challenge\n     * @param challengeId The challenge from which funds were withdrawn\n     * @param user The address that withdrew the funds\n     * @param amount The amount of tokens withdrawn\n     * @dev This event is currently defined but not used in the current implementation\n     */\n    event ChallengeFundsWithdrawn(uint256 challengeId, address user, uint256 amount);\n\n    /**\n     * @notice Emitted when a user submits their work for a challenge\n     * @param submissionId The unique identifier of the submission within the challenge\n     * @param challengeId The challenge this submission belongs to\n     * @param submitter The address of the user who made the submission\n     */\n    event SubmissionCreated(uint256 challengeId, uint256 submissionId, address submitter);\n\n    /**\n     * @notice Emitted when a user withdraws their earned rewards\n     * @param from The address that withdrew the funds\n     * @param to The address that received the funds\n     * @param amount The amount of tokens withdrawn\n     */\n    event FundsWithdrawn(address from, address to, uint256 amount);\n}"
      },
      "project/contracts/interfaces/IEscrow.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IEscrowErrors} from \"./IEscrow.errors.sol\";\nimport {IEscrowEvents} from \"./IEscrow.events.sol\";\nimport {IEscrowStructs} from \"./IEscrow.structs.sol\";\n\n// Escrow contracts for bookings\n\ninterface IEscrow is IEscrowErrors, IEscrowEvents, IEscrowStructs {\n    /// @notice Owner calls this function to create a challenge\n    function createChallenge(\n        string calldata metadataURI,\n        uint256 poolSize,\n        uint256 deadline\n    ) external;\n\n    /// @notice Read challenge instance\n    function getChallenge(uint256 challengeId) external view returns (Challenge memory);\n\n    /// @notice Read all challenges\n    function getChallenges(uint256 startIndex, uint256 count) external view returns (Challenge[] memory);\n\n    /// @notice Get the number of challenges\n    function getChallengesCount() external view returns (uint256);\n\n    /// @notice Get the challenges for which the user is the admin\n    function getAdminChallenges(address admin) external view returns (uint256[] memory);\n\n    /// @notice User calls this function to create a submission\n    function createSubmission(uint256 challengeId, string calldata contact, string calldata submissionURI) external;\n\n    /// @notice Read submission instance\n    function getSubmission(uint256 challengeId, uint256 submissionId) external view returns (Submission memory);\n\n    /// @notice Read all submissions for a challenge\n    function getSubmissions(uint256 challengeId, uint256 startIndex, uint256 count) external view returns (Submission[] memory);\n\n    /// @notice Get the number of submissions for a challenge\n    function getSubmissionsCount(uint256 challengeId) external view returns (uint256);\n\n    /// @notice Owner calls this function to resolve a challenge\n    function resolveChallenge(\n        uint256 challengeId,\n        uint256[] calldata awardedSubmissions,\n        uint256[] calldata ineligibleSubmissions\n    ) external;\n\n    /// @notice User calls to withdraw funds from the escrow\n    function withdraw(uint256 amount, address to) external;\n\n    /// @notice Read the balance of an account\n    function getBalance(address account) external view returns (uint256);\n}\n"
      },
      "project/contracts/interfaces/IEscrow.structs.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title IEscrowStructs\n * @notice Interface defining all data structures used by the Escrow contract\n * @dev These structs organize challenge and submission data in a standardized format\n */\ninterface IEscrowStructs {\n    enum ChallengeStatus {\n        Active,\n        Completed\n    }\n\n    /**\n     * @notice Challenge data structure containing all information about a challenge\n     * @param uri URI pointing to off-chain metadata (description, requirements, submission guidelines, etc.)\n     * @param poolSize The total reward pool size in tokens for this challenge\n     * @param endsAt Unix timestamp after which no new submissions are accepted and challenge can be resolved\n     * @param createdAt Unix timestamp when the challenge was created\n     */\n    struct Challenge {\n        string metadataUri;\n        address admin;\n        uint256 poolSize;\n        uint256 endsAt;\n        uint256 createdAt;\n        ChallengeStatus status;\n    }\n\n    enum SubmissionStatus {\n        Pending,\n        Ineligible,\n        Accepted,\n        Awarded\n    }\n\n    /**\n     * @notice Submission data structure containing information about a user's submission to a challenge\n     * @param uri URI pointing to the actual submission content (work, deliverables, proof, etc.)\n     * @param submitter The address of the user who made this submission\n     * @param contact The contact information of the user who made this submission\n     * @param createdAt Unix timestamp when the submission was created\n     */\n    struct Submission {\n        string metadataUri;\n        address creator;\n        string creatorContact;\n        SubmissionStatus status;\n        uint256 createdAt;\n    }\n}\n"
      }
    }
  }
}